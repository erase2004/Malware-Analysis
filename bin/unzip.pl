#!/usr/bin/perl
use strict;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use FileHandle;
use Archive::Zip;
use Archive::Zip qw( :ERROR_CODES );
use URI::Escape;
use File::Copy;
use File::Path;
use Cwd;

use constant FILE_DIR => '/files';
use constant DIR_INFO => 'dir.txt';
use constant PAIR_INFO => 'pair.txt';
use constant EXCEPT_INFO => 'except.txt';
use constant NOTICE => 'FIN';
use constant WARN => 'ERROR';
use constant WEND => 'END';

my @apkFileList;
my @hashFileList;
my $fileCount;
my $failCount = 0;
my @condCodeList;

chdir('..');
my $homedir = getcwd;
chdir($homedir.FILE_DIR);
opendir(my $dh, $homedir.FILE_DIR);
@apkFileList = grep { /.apk$/i } readdir($dh);  ##取得目錄下的apk檔案清單
close($dh);

if(defined $apkFileList[0])
{
    my $md5 = Digest::MD5->new;
    my $fh;
    my $ae;
    for(my $i = 0; $i <= $#apkFileList; ++$i) {  ##將.apk結尾取代成.zip,創建以檔案md5值,所形成字串的資料夾,
                                                 ##然後再將檔案解壓縮自該資料夾
        my $weird_name = $apkFileList[$i];
        $apkFileList[$i] = uri_escape($apkFileList[$i]);
        if($weird_name ne $apkFileList[$i]) {
            copy($weird_name, $apkFileList[$i]);
            unlink($weird_name);
        }
        $_ = $apkFileList[$i];
        /.apk$/i;
        rename($apkFileList[$i], $`.".zip");
        $apkFileList[$i] = $`.".zip";
        undef $fh;
        undef $ae;
        $fh = FileHandle->new;
        $fh->open($apkFileList[$i]) || (print (WARN."\n\[Error\] Can't open ".$apkFileList[$i].WEND."\n"), $condCodeList[$i] = 1, 
                                                                              $failCount++, next); 
        $md5->addfile($fh);
        $hashFileList[$i] = $md5->hexdigest;
        mkdir($hashFileList[$i],0740) || (print (WARN."\n\[Error\] Create directory - ".$hashFileList[$i]." - failed.\n".WEND."\n"),
                                          $condCodeList[$i] = 2, $failCount++, next);
        $ae = Archive::Zip->new();
        unless ( $ae->read($apkFileList[$i] ) == AZ_OK ) {
            print (WARN."\n\[Error\] ".$apkFileList[$i]." has something wrong.\n".WEND."\n");
            rmdir($hashFileList[$i]);
            $condCodeList[$i] = 3;
            $failCount++;
            next;
        }
        my @member = $ae->members();
        if($member[0]->isEncrypted()) {
            print (WARN."\n\[Info\] ".$apkFileList[$i]." is Encryted.\n".WEND."\n");
            rmdir($hashFileList[$i]);
            $condCodeList[$i] = 4;
            $failCount++;
        }
        else {
            unless ( $ae->extractTree('', $hashFileList[$i]."\/") == AZ_OK ) {
                print (WARN."\n\[Error\] Unzip ".$apkFileList[$i]." failed.\n".WEND."\n");
                $condCodeList[$i] = 5;
                rmtree($homedir.FILE_DIR."\/".$hashFileList[$i], 0, 0);
                $failCount++;
            }
        }
    }
    undef $fh;
    undef $ae;
    print NOTICE."\n";                           ##回傳FIN訊號和檔案數給daemon,並將目錄資訊記錄在dir.txt內,
    $fileCount = $#apkFileList + 1 - $failCount;              ##供toSmali.pl使用
    print $fileCount."\n";

    $fh = FileHandle->new(">".DIR_INFO);
    my $fh2 = FileHandle->new(">>".PAIR_INFO);
    my $fh3 = FileHandle->new(">".EXCEPT_INFO);
    for(my $i = 0; $i <= $#apkFileList; ++$i) {
        if($condCodeList[$i] == 0) {
            print $fh $hashFileList[$i]."\n";
            print $fh2 $apkFileList[$i]."\n";
            print $fh2 $hashFileList[$i]."\n";
        }
        else {
            print $fh3 $apkFileList[$i]."\n".$condCodeList[$i]."\n";
        }
    }
    undef $fh;
    undef $fh2;
}
else
{
    print NOTICE."\n";
    $fileCount = 0;
    print $fileCount."\n";
}

