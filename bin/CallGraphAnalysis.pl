#!/usr/bin/perl
use strict;
use Graph::Directed;
use DBI;
use FileHandle;

use constant FILE_DIR => '/files';
use constant BIN_DIR => '/bin';
use constant SECRET => 'secret.txt';
use constant SRC => 'Source';
use constant SINK => 'Sink';
use constant NON => 'None';
use constant MIX => 'Mix';

sub setAttrAndSearchMixP;

my $execCode;
my $file = shift;
my $homedir = shift;
my @callList;
my $host = "localhost";
my $database = "permission";

my $fh = FileHandle->new($homedir.BIN_DIR."\/".SECRET);

$_ = $fh->getline;
my @tQue = split(':',$_);
my $user = substr($tQue[1], 0, length($tQue[1]) - 1);
$_ = $fh->getline;
@tQue = split(':',$_);
my $password = substr($tQue[1], 0, length($tQue[1]) - 1);
undef $fh;

$execCode = "java -jar ".$homedir.BIN_DIR."\/javacg-static.jar ".$file;
@callList = `$execCode`;

my $CG = Graph::Directed->new;
my $caller;
my $callee;

for(my $i = 0; $i <= $#callList; ++$i) {
    $_ = $callList[$i];
    if(/^M:/) {
        $_ = $';
        @tQue = split(' ',$_);
        $caller = $tQue[0];
        $_ = $tQue[1];
        /\(\w+\)/;
        $callee = $';
        $CG->add_vertex($caller);
        $CG->add_vertex($callee);
        $CG->add_edge($caller,$callee);
    }
}
my @allV = $CG->vertices;
my @sosV;

my $driver = "mysql";
my $db = DBI->connect("DBI:$driver:database=$database;host=$host", $user, $password);
for(my $i = 0; $i <= $#allV; ++$i) {
    @tQue = split(":",$allV[$i]);
    my $method = $tQue[1];
    @tQue = split(".",$tQue[0]);
    my $class = $tQue[$#tQue];
    $execCode = "SELECT class, method, Permission, SourceOrSink FROM api WHERE class=\'$class\' AND method=\'$method\'";
    my $sth = $db->prepare($execCode);
    my $cond = $sth->execute();
    if($cond > 0) {
        my ( $tclass, $tmethod, $tperm, $tsos);
        $sth->bind_columns( undef, \$tclass, \$tmethod, \$tperm, \$tsos);
        $sth->fetch();
        if($tsos eq SRC) {
            $CG->set_vertex_attribute($allV[$i], undef, SRC);
            push(@sosV, $allV[$i]);
        } elsif($tsos eq SINK) {
            $CG->set_vertex_attribute($allV[$i], undef, SINK);
            push(@sosV, $allV[$i]);
        } else {
            $CG->set_vertex_attribute($allV[$i], undef, NON);
        }
    }
    $sth->finish();
}
$db->disconnect();

my @mixV;
for(@sosV) {
    setAttrAndSearchMixP($_);
}

sub setAttrAndSearchMixP {
    my $node = shift;
    my $type = $CG->get_vertex_attribute($node, undef);
    my @preV = $CG->predecessors($node);
    
    while($#preV) {
        $node = shift(@preV);
        my $ttype = $CG->get_vertex_attribute($node, undef);
        if($type eq MIX) {
            $CG->set_vertex_attribute($node, undef, MIX);
        } elsif($ttype ne NON) {
            if($type eq $ttype) {
                $CG->set_vertex_attribute($node, undef, $type);
            } else {
                $CG->set_vertex_attribute($node, undef, MIX);
                if(($type ne MIX) && ($$type ne MIX)) {
                    push(@mixV, $node);
                }
            }
        } else {
            $CG->set_vertex_attribute($node, undef, $type);
        }

        if($CG->is_source_vertex($node)) {
            next;
        }
        else {
            my @tpreV = $CG->predecessors($node);
            for(my $j = $#tpreV; $j >= 0; --$j) {
                unshift(@preV,$tpreV[$j]);
            }
        }
    }
}
